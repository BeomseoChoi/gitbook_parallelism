# 코어

---

## 싱글 코어

CPU는 코어를 갖는다. 과거에는 1 CPU, 1 Core, 1 Thread인 싱글코어였다. 당시에는 코어에 사용되는 트랜지스터 개수를 증가시킴으로써 코어의 성능 향상을 꾀했다. 무어의 법칙이라는게 존재할 정도로 이 시기에는 집적회로의 트랜지스터 개수가 엄청나게 증가했다.

![[resources/image/Transistor_count_trends.png]]

트랜지스터를 한정된 공간에 더 많은 양을 욱여넣기 위해 트랜지스터의 크기는 작아져야했다. 10나노, 7나노 공정처럼 트랜지스터의 크기는 점차 작아져갔고, CPU에 사용되는 트랜지스터 개수는 그만큼 증가했다. 하지만 트랜지스터의 개수가 늘어난 만큼 CPU의 발열과 전력소모가 문제가 되었고, 트랜지스터의 크기가 작아지는 만큼 양자 터널링이 문제가 됐다.

이러한 이슈로 트랜지스터를 이용해 CPU 코어의 성능 향상을 꾀하기보다는 CPU 코어의 개수를 증가시켜 CPU의 성능 향상을 이루고자 했다. 이러한 배경으로 싱글 코어가 아닌 멀티 코어가 시작되었다.

## 멀티 코어

싱글 코어의 첫 문단에서 1 CPU, 1 Core, 1 Thread 문장을 적었다. 하지만 멀티 코어 세상이 오면서 1 CPU, N Core, N Thread가 됐다. 1개의 CPU는 N개의 코어를 가지게 됐고, 각 코어는 하나의 스레드를 처리할 수 있다.

이제 코어를 말할 때, 물리 코어인지 논리 코어인지 구분해야한다. 물리 코어는 CPU 내에 물리적으로 존재하는 코어이다. 지금까지 말한 코어가 물리 코어이다. 논리 코어는 CPU가 한번에 처리할 수 있는 스레드이다. CPU에 6개의 코어가 존재하고, 각 코어가 1개의 스레드를 처리할 수 있다면, 물리 코어는 6개이고, 논리 코어도 6개이다.

# Simultaneous Multi-Threading

---

Simultaneous Multi-Threading(이하 SMT)는 1개의 코어가 1개의 스레드가 아닌 다수의 스레드를 처리할 수 있도록 하는 기술이다. 인텔의 하이퍼 스레딩이 대표적인 예시로, 하이퍼 스레딩이 적용된 인텔 CPU의 물리 코어가 6개이고, 각 코어가 동시에 2개의 스레드를 처리할 수 있다면 논리 코어는 12개가 된다. 이처럼 코어가 다수의 스레드를 동시에 처리하는 멀티스레딩을 수행할 수 있도록 하는 것이 SMT이다.

멀티 스레딩 또한 구분을 해야하는데, Temporal Multi-Threading(이하 TMT)과 SMT가 있다. 이 둘의 차이는 주어진 파이프라인에서 한 클럭에 몇개의 스레드가 동시에 처리될 수 있는지이다. TMT는 한 클럭에 1개의 스레드가, SMT는 2개 이상의 스레드가 동시에 처리된다.

![[SMT.png]]

TMT는 Coarse-grained(이하 CMT) 방식과 Fine-grained(이하 FMT) 방식으로 구분된다. CMT는 하나의 코어에서 한 스레드가 작업 도중 캐시 미스, I/O 인터럽트 등 긴 레이턴시가 발생하면 다른 스레드에게 권한을 넘겨주는 방식이다. FMT는 클록 사이클마다 스레드를 전환해가며 실행하는 방식이다. CMT와 FMT는 실행 단위가 하나이다. 위에서 말했듯이 1개의 코어가 한 클럭에 1개의 스레드만 처리 가능하다.

CMT와 FMT 그림을 보면 한 클럭에 하나의 스레드만 처리된다. SMT를 구현하면 한 클럭에 여러 스레드가 동시에 처리될 수 있다.

![[Pasted image 20250322232957.png]]

1 코어, 1 스레드의 경우, 하나의 코어에서 하나의 스레드가 파이프라인을 점유한다. 코어에는 ALU뿐만 아니라 FPU, MMX, SSE 등 다양한 처리 유닛이 존재한다. 하나의 스레드가 파이프라인을 점유하면서 ALU를 사용하는 동안 FPU, MMX, SSE는 유휴 상태에 빠지게 된다. 이런 낭비를 줄이기 위하여 유휴 상태인 다른 처리 유닛을 다른 스레드가 사용할 수 있도록 해야 한다.

![[Pasted image 20250322233011.png]]

이 사진을 보면 하나의 물리 코어에 2개의 논리 코어가 존재한다. 두 스레드가 동시에 처리될 수 있도록 레지스터 파일은 논리 코어마다 가지고 있다. 그리고 논리 코어는 처리 유닛과 캐시를 공유한다. 만약 1번 논리 코어가 ALU를 사용한다면 2번 논리 코어는 동시에 FPU를 사용함으로써 한 클럭 동안 유휴 상태인 처리 유닛을 가능한 적게 만드는 것이다. 하나의 물리 코어에 다수의 논리 코어를 이용하여 구현한 SMT를 ‘Multi-Way SMT’라고 부른다. 위 사진은 2-Way SMT이다.

SMT를 사용한다고 하더라도 결국 물리 코어의 최대 성능을 능가하진 못한다. 다만 한 클럭에 여러 스레드가 동작하도록 하여 가능한 유휴 상태인 처리 유닛을 줄여 성능 향상을 얻는다.

하지만 SMT로 항상 성능 향상을 얻을 수 있는 것은 아니다. 한 물리 코어가 두 논리 코어를 갖고 이 두 논리 코어가 캐시를 공유하는 경우, 1번 논리 코어에 캐시 미스, I/O 인터럽트 등 레이턴시가 긴 작업이 발생한 경우, 2번 논리 코어가 작업을 하면서 1번 논리 코어의 캐시를 모두 망가뜨릴 수 있다. 그래서 1번 논리 코어가 긴 작업이 마친 후 다음 작업을 수행하려고 하는데 캐시에 쌓아놨던 데이터가 없어서 캐시 미스가 발생할 수 있다.

---

# Multi Processor

---

## Symmetric Multi-Processor

지금까지 설명한 바로는 우리의 컴퓨터는 1 CPU, N Core, kN Thread를 사용한다. 즉 멀티 코어 프로세싱에 대해 다뤘다. 하지만 CPU(프로세서)가 1개일 필요는 없다. 이제는 프로세서의 개수를 증가시키고자 한다.

![[Pasted image 20250322233031.png]]

Symmetric Multi Processing(이하 SMP) 아키텍쳐는 다중 프로세서 시스템에서 프로세서가 Main Memory를 Share한다. 프로세서는 메모리보다 빠르게 동작하기 때문에 메인 메모리에 접근하는 것은 비용이 크다.

메모리 버스를 공유하기 때문에 여러 프로세서가 동시에 접근할 수 없다. 하나의 프로세서만 동일한 메모리에 접근 가능하다. 이처럼 안그래도 접근 속도가 느린데 여러 프로세서가 메모리에 접근하기 위해 일부 프로세서는 대기를 해야하는 상황이 발생한다. 따라서 단순히 프로세서의 개수를 늘리는 것 만으로는 멀티 프로세서의 이점을 제대로 취할 수 없다.

## Non-Uniformed Memory Access

![[Pasted image 20250322233045.png]]

Non-Uniformed Memory Access(이하 NUMA)는 SMP의 단점을 개선시킨 아키텍쳐이다. 각 프로세서가 메모리를 공유하는 것이 아니라, 자신만의 메모리를 가지게 된다. Memory Organization에서 전자를 Distributed Memory(a), 후자를 Distributed Memory(b)라고 한다.

![[Pasted image 20250322233059.png]]

NUMA에서 CPU와 그 CPU의 메모리를 묶어서 ‘NUMA 노드’라고 한다. 그리고 실행 중인 스레드를 기준으로 ‘Local memory’와 ‘Remote memory’가 구분된다. 스레드가 CPU 0에서 실행되고 있을 때, Memory 0, 1, 2, 3은 Local memory이고, Memory 4, 5, 6, 7은 Remote memory이다.

당연히 Local memory에 접근하는 것이 Remote memory에 접근하는 것보다 빠르다. 그리고 Remote memory access time / Local memory access time을 ‘NUMA Ratio’라고 한다.

이런 구조를 이용해서 NUMA 아키텍쳐는 SMP보다 확장성과 속도가 우수해진다.